{"meta":{"title":"LifeNobody","subtitle":"(+_+)?","description":"博客，挖坑常在~~~","author":"LifeNobody","url":"https://lifenobody.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-06-22T07:18:27.000Z","updated":"2020-07-05T09:53:35.310Z","comments":true,"path":"categories/index.html","permalink":"https://lifenobody.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-06-22T07:18:58.000Z","updated":"2020-06-28T08:17:06.817Z","comments":true,"path":"about/index.html","permalink":"https://lifenobody.github.io/about/index.html","excerpt":"","text":"专业技能1.在大量实战中应用 HTML+CSS 进行样式布局，能制作符合标准规范的页面，并能处理部分的浏览器兼容问题2.知晓组件化开发、面向对象、原型继承、事件机制、js 解析，并用原生 js 组件化开发过简易商城3.了解 es6 基本语法，对象扩展、Promise、Class4.了解 JQuery、Bootstrap、ElementUI、Swiper、Sass、Stylus 等第三方库5.熟悉 Vue，用 Vue 写过简单的购物商城，了解指令、生命周期钩子、路由配置、组件传值、插槽等重要常用的技术6.了解响应式布局、移动端屏幕适配7.熟悉 Git 常见操作 1.简易仿淘宝网1.使用Vue+Swiper开发的一个简易淘宝网，布局样式上一个要点就是页面抖动问题，用块元素将图片包裹起来，设置百分比宽或百分比下边距帮图片占据位置，这样当图片还未完全加载时，下面的元素也不会占据图片的位置了。2.另一个要点就是首页下拉刷新和上拉加载更多，监听滚动事件，当屏幕滚动到一定高度时触发刷新事件和加载事件，这样就能实现刷新和加载事件。3.还有一点是搜索页的搜索词列表和分类页的各个类别。从淘宝扒的API，在获取的过程中会有加载中的提示，获取到数据后利用v-for循环展示。 2.简易仿去哪儿网移动端1.使用Vue+Swiper开发的一个简易去哪儿网，布局样式上一个要点就是页面抖动，用块元素将图片包裹起来，设置百分比宽或百分比下边距帮图片占据位置，这样当图片还未完全加载时，下面的元素也不会占据图片的位置了。2.另外一个要点是父子组件传值，使用Vuex，用state保存默认城市，当在城市选择页面引入Vuex的state和mutation方法，这样就可在子组件中改变城市，并且首页的城市会相应地做出改变。 3.简易响应式布局网站模仿三星官网开发的一个简易网站，主要通过媒体查询监听浏览器宽度，在不同的宽度下应用不同的样式，改变页面布局。"},{"title":"tags","date":"2020-06-22T07:17:32.000Z","updated":"2020-07-05T09:52:25.849Z","comments":true,"path":"tags/index.html","permalink":"https://lifenobody.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js基础","slug":"js基础","date":"2020-07-01T10:13:31.000Z","updated":"2020-07-05T13:59:33.493Z","comments":true,"path":"2020/07/01/js基础/","link":"","permalink":"https://lifenobody.github.io/2020/07/01/js%E5%9F%BA%E7%A1%80/","excerpt":"","text":"基本数据类型数据类型基本类型（值类型），在栈中开辟一块空间给变量，再将值放在变量的内存空间中：String，Number、Bollean、null、undefined 引用类型，在栈中开辟一块空间给变量，存放数据在堆中的地址，在堆中开辟一块空间存放数据，将数据的地址赋值给变量：Object、Array、Function null与undefinednull 和 undefined 基本是同义的，只有一些细微的差别。null 表示已被定义，定义为“空值”。典型用法是：（1）作为函数的参数，表示该函数的参数不是对象。（2）作为对象原型链的终点。见例 3 undefined 表示根本不存在定义，”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：（1）变量被声明了，但没有赋值时，就等于 undefined。（2）调用函数时，应该提供的参数没有提供，该参数等于 undefined。（3）对象没有赋值的属性，该属性的值为 undefined。（4）函数没有返回值时，默认返回 undefined。见例 4 示例 e.g.1 null： Q：有张三这个人吗？ A：有 Q：在哪？ A：死了 undefined： Q：有张三这个人吗？ A：没 e.g.2 null表示房已盖好，没人要的、待售的空房。 undefined表示连房子都还没盖 e.g.3 Object.getPrototypeOf(Object.prototype)// null e.g.4 var i; i // undefined function f(x){console.log(x)} f(); // undefined var o = new Object(); o.p // undefined var x = f(); x // undefined js的内置函数抛开环境，一些js的数据封装类对象 Object Array Boolean Number String Function Date RegExp Error Math 原型构造函数new对象的过程用new调用构造函数时发生了什么：1.创建一个空的对象2.把构造函数的prototype属性作为空对象的原型3.this赋值为这个空对象4.执行函数5.如果函数没有返回值则默认返回this（返回之前那个空对象）上面第2步非常重要，正是有了原型链，可以达到类似继承的效果。 构造函数的语法糖var a = {}其实是var a = new Object()的语法糖var a = []其实是var a = new Array()的语法糖function Foo(){…}其实是var Foo = new Function(…)的语法糖 原型规则所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了null意外），如例1.所有的引用类型（数组、对象、函数），都有一个proto（隐式原型）属性，属性值是一个普通的对象，如例2.所有的函数，都有一个prototype（显示原型）属性，属性值也是一个普通的对象，如例3.所有的引用类型（数组、对象、函数），proto属性值指向它的构造函数的prototype属性值，如例4. 代码片段 e.g.1 var obj = {}; obj.a = 100; var arr = []; arr.a = 100; function fn () {} fn.a = 100; e.g.2 console.log(obj.__proto__); console.log(arr.__proto__); console.log(fn.__proto__); e.g.3 console.log(fn.prototype) e.g.4 console.log(obj.__proto__ === Object.prototype) 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么就会去它的proto（即它的构造函数的prototype）中寻找。如例5.f对象本身没有alertName属性，此时就会去f对象的proto中寻找alertName，在构造函数Foo中找到了alertName，就调用了Foo的alertName方法。 代码片段 e.g.5 function Foo(name, age) { this.name = name } Foo.prototype.alertName = function () { alert(this.name) } var f = new Foo(&apos;zhangsan&apos;) f.printName = function () { console.log(this.name) } f.printName() f.alertName() 用for…in遍历对象的时候，会遍历对象的所有属性（参见es6文档的“es6之for…of与for…in”）。现代高级浏览器已经在 for…in 中屏蔽了来自原型的属性，但是这里建议还是加上hasOwnProperty判断，保证遍历的确实是对象本身的属性，而不是来自原型的属性。如例6. 代码片段 e.g.6 var item for (item in f) { if (f.hasOwnProperty(item)) { console.log(item) } } 原型链接上节例5，在最后加一句f.toString()。因为f本身没有toString()，并且f.proto（即Foo.prototype）中也没有toString()，那么就继续去f.proto.proto中寻找，因为f.proto就是一个普通的对象而已。直到找到最上层都没有找到，那么就宣告失败，返回undefined。最上层是什么 ———— Object.prototype.proto === null，这是特例，避免死循环。这样一直往上找，会发现是一个链式的结构，所以叫做“原型链”。 instanceof与typeof判断一个变量是不是某种类型（数组、对象、函数等）用instanceof。例5中，要计算f instanceof Foo是不是正确，就要判断f的原型一层一层往上，能否对应到Foo.prototype。同理，如果要计算f instanceof Object是不是正确，就要判断f的原型一层一层往上，能否对应到Object.prototype。typeof只能粗略判断f是个对象，不能判断属于哪个对象。见例7. 代码片段 e.g.7 function Foo(name, age) { this.name = name } var f = new Foo(&apos;zhangsan&apos;) console.log(typeof f);// object console.log(f instanceof Foo)// true 原型链中的this所有的从原型或者更高级的原型中得到、执行的方法，其中的this在执行时，就指向了当前这个触发事件执行的对象。因此printName和alertName中的this都是f。 原型链代码示例 代码片段 e.g.1 function DomElement(id) { this.elem = document.getElementById(id); } DomElement.prototype.html = function (val) { const elem = this.elem; if (val) { elem.innerHTML = val; return this; } else { return elem.innerHTML; } } DomElement.prototype.on = function (type, fn) { const elem = this.elem; elem.addEventListener(type, fn); return this; } let box = new DomElement(&apos;d&apos;); box.html(&apos;&lt;h1&gt;hehe&lt;/h1&gt;&apos;).on(&apos;click&apos;, () =&gt; { console.log(&apos;233click&apos;); }) e.g.2 // 构造函数 function DomElement(selector) { var result = document.querySelectorAll(selector) var length = result.length var i for (i = 0; i &lt; length; i++) { this[i] = result[i] } this.length = length } // 修改原型 DomElement.prototype = { constructor: DomElement, get: function (index) { return this[index] }, forEach: function (fn) { var i for (i = 0; i &lt; this.length; i++) { const elem = this[i] const result = fn.call(elem, elem, i) if (result === false) { break } } return this }, on: function (type, fn) { return this.forEach(elem =&gt; { elem.addEventListener(type, fn, false) }) } } // 使用 var $div = new DomElement(&apos;div&apos;) $div.on(&apos;click&apos;, function () { console.log(&apos;click&apos;) }) thisthis在执行时才能确认指向，定义时无法确认。因为this是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。 可有以下几个简单方法判断：1.检查 ‘ . ‘ 左边是谁invoke 这个函数. 例如 xiaoming.age(); age函数里面有this, 然后 ‘. ‘ 旁边是xiaoming , 那么this就是指向xiaoming了.这种叫做 Implicit Binding.2.如果点旁边没有,那就检查有没有用到 bind, apply, call 这三种, 有的话就是调用此方法的对象. 这种叫做 explicit binding.3.如果上面两个都没有就检查代码里面有没有用到new 这个keyword, 有的话那就是指向new旁边的函数对象. 这种叫做new binding4.上面三个都没有, 检查是不是有arrow function, 有arrow function的话就是, 那么指向是arrow function的lexical binding 的对象. 就是她的parent. 这种叫做 lexical binding5.全部都没有如果不是strict mode那就是window对象了.. strict就是 error (undefined). this执行会有不同，主要集中在这几个场景中：作为构造函数执行，如例1.作为对象属性执行，如例2.作为普通函数执行，如例3.用于call、apply、bind，如例4、5、6. 代码片段 e.g.1 function Fn (name) { this.name = name; console.log(this);//{name:”hehe”} } var f = new Fn(&apos;hehe&apos;); console.log(f);//{name:”hehe”} e.g.2 var obj = { name: &apos;hehe&apos;, logName: function () { console.log(this); } } obj.logName();// obj e.g.3 function fn () { console.log(this); } fn();// window e.g.4 function fn (name, age) { console.log(name);// hehe console.log(this);// { x: 100 } } fn.call({ x: 100 }, &apos;hehe&apos;, 20); e.g.5 function fn (name, age) { console.log(name);// hehe console.log(this);// { x: 200 } } fn.apply({ x: 200 }, [&apos;hehe&apos;, 20]); e.g.6 var fn = function (name, age) { console.log(name);// hehe console.log(this);// { x: 300 } }.bind({ x: 300 }) fn(&apos;hehe&apos;, 20); 执行上下文执行上下文用于描述运行Javascript代码的环境。在一段JS脚本（即一个&lt;\\script&gt;标签中或一个JS文件中）执行之前，会先创建一个全局执行上下文环境，进行一些准备工作，这里的“准备工作”，就叫做”执行上下文”，也叫执行上下文环境，也叫执行环境。就是先把代码中即将执行的变量定义、函数声明（不是“函数表达式”）都拿出来（函数内部的不算，因为不知道函数何时执行），变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。强调，这是在代码执行之前才开始的工作。 另外，一个函数在执行之前，会创建一个函数执行上下文环境，跟全局上下文差不多，不过函数执行上线文中会多出this、arguments和函数的参数。 一个执行上下文的生命周期可以分为两个阶段：创建阶段和执行阶段。 创建阶段：创建变量对象，建立作用域链，以及确定this的指向。 执行阶段：创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。 作用域作用域JS只有全局作用域和函数作用域，无块级作用域。作用域就是一个独立的地盘，让变量不会外泄、暴露出去。 全局作用域就是最外层的作用域，如果不是在某个函数中定义变量，那么这些变量就都在全局作用域中。这样的坏处就是很容易撞车。这就是为何jquery、zepto等库的源码，所有的代码都会放在(function(){})()中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。 例1中这样的代码块，算不上函数作用域，更别说全局作用域。在代码块里面声明的变量依然能被外面访问到，实质的样子就是例2. 代码片段 e.g.1 if (true) { var a = 233; } console.log(a); e.g.2 var a; if (true) { a = 233; } console.log(a); 关于作用域有个很典型的例子，之前踩过的坑。如下例3，要求创建10个a标签，点击显示各自的序号。但是例3中不管点击哪个，显示的永远是10.原因就是i是全局变量，循环执行完，但是点击事件并不一定执行。当触发点击事件时，点击事件中的i需要到全局作用域寻找， 然而此时的i早就循环完变成10了（for循环停止条件是i&lt;10，此时i=9，但是停止循环后还会执行一下i++，所以最后的i是10，这是10的由来），所以永远显示10.解决方法如例4，将代码封装成一个自执行函数，函数中的i由参数传递进来，这样每遍循环的函数作用域中的i都是不同的。es6规定块级作用域前常用此方法。 也可像例5，直接用let声明i，let会创建块级作用域，每遍循环的块级作用域中的i都是不同的。 代码片段 e.g.3 var i, a for (i = 0; i &lt; 10; i++) { a = document.createElement(&apos;a&apos;) a.innerHTML = i + &apos;&lt;br&gt;&apos; a.addEventListener(&apos;click&apos;, function (e) { e.preventDefault() console.log (i) }) document.body.appendChild(a) } e.g.4 var i for (i = 0; i &lt; 10; i++) { (function (i) { var a = document.createElement(&apos;a&apos;) a.innerHTML = i + &apos;&lt;br&gt;&apos; a.addEventListener(&apos;click&apos;, function (e) { e.preventDefault() console.log (i) }) document.body.appendChild(a) })(i) } e.g.5 var a; for (let i = 0; i &lt; 10; i++) { a = document.createElement(&apos;a&apos;) a.innerHTML = i + &apos;&lt;br&gt;&apos; a.addEventListener(&apos;click&apos;, function (e) { e.preventDefault() console.log(i) }) document.body.appendChild(a) } 作用域链首先认识一下什么叫做自由变量。例1中，console.log(a)要得到a变量，但是在当前的作用域（指函数作用域）中没有定义a。当前作用域没有定义的变量，这就是自由变量。自由变量如何得到？向父级作用域（函数在哪个作用域中定义的，这个作用域就是函数的父级作用域。函数的父级作用域是函数定义时的父级作用域，不是函数执行时的父级作用域。例1中函数的父级作用域就是全局作用域，因为函数定义在全局作用域中。例2中，F2的父级作用域就是F1的作用域，F1的父级作用域就是全局作用域。）寻找。如果父级作用域也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。 代码片段 e.g.1 var a = 100 function fn() { var b = 200 console.log(a)//100 自由变量 console.log(b)//200 } fn() e.g.2 var a = 100 function F1() { var b = 200 function F2() { var c = 300 console.log(a)//100 自由变量 console.log(b)//200 自由变量 console.log(c)//300 } F2() } F1() 闭包解释函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。可粗略地理解为闭包就是一个内部函数。在JS中，每当函数被创建，就会在函数生成时生成闭包。 下例1中，displayName()函数内没有name变量，所以会向父级作用域找name，然后打印出来（作用域链的知识）。这个词法作用域的例子描述了分析器如何在函数嵌套的情况下解析变量名。词法（lexical）一词指的是，词法作用域根据源代码中声明变量的位置来确定该变量在何处可用。嵌套函数可访问声明于它们外部作用域的变量。 代码片段 e.g.1 function init() { var name = &quot;hehe&quot;; // name是一个被init创建的局部变量 function displayName() { // displayName()是内部函数，一个闭包 console.log(name); // hehe } displayName(); } init(); 下例2运行的效果和例1完全一样。其中不同的地方在于内部函数displayName()被当作返回值，在执行前，从外部函数返回。 一般情况下，一个函数中的局部变量生存时间仅在于此函数的执行期间，一旦makeFunc()执行完毕，name变量将不能再被访问，然而，在makeFunc()执行完毕后，执行myFunc();输出hehe。原因在于，JS中的函数形成了闭包。 闭包是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。myFunc是执行makeFunc时创建的对displayName函数实例的引用。displayName的实例维持了一个对它的词法环境（变量 name 存在于其中）的引用。因此，当myFunc被调用时，变量name仍然可用，其值就被打印出来。 代码片段 e.g.2 function makeFunc() { var name = &quot;hehe&quot;; function displayName() { console.log(name); } return displayName; } var myFunc = makeFunc(); myFunc();// hehe 应用最大的应用就是封装变量，收敛权限。见例1，判断某个数字是否出现过，执行isFirstLoad，将返回的函数赋值给变量firstLoad，执行firstLoad，这个函数就会去父级作用域找变量_list。对外界来说不可能修改_list的，这就是收敛权限。 代码片段 e.g.1 function isFirstLoad() { var _list = [] return function (id) { if (_list.indexOf(id) &gt;= 0) { return false } else { _list.push(id) return true } } } var firstLoad = isFirstLoad() console.log(firstLoad(10)); // true console.log(firstLoad(10)); // false console.log(firstLoad(20)); // true console.log(firstLoad(20)); // false 异步解释简单来讲，不会阻塞后面程序的运行就叫异步，如例1。定时器是异步执行的，输出顺序是100、300、200.执行完100后，并不会等1s再执行200，再执行300，而是执行完100后再执行300，等1s再执行200. 阻塞了就是同步，如例2。执行完100后，用户点击200后，才执行300. 异步与同步的最大区别就是阻塞与否。 代码片段 e.g.1 console.log(100) setTimeout(function () { console.log(200) }, 1000) console.log(300) e.g.2 console.log(100) alert(200) // n秒钟之后点击确认 console.log(300) 应用场景简单来讲，就是需要等待的场景就需要异步。 定时器setTimeout、setInverval，如例1 网络请求，如ajax、加载，如例2、例3 事件绑定，如例4 代码片段 e.g.1 console.log(100) setTimeout(function () { console.log(200) }, 1000) console.log(300) e.g.2 console.log(&apos;start&apos;) $.get(&apos;./data1.json&apos;, function (data1) { console.log(data1) }) console.log(&apos;end&apos;) e.g.3 console.log(&apos;start&apos;) var img = document.createElement(&apos;img&apos;) img.onload = function () { console.log(&apos;loaded&apos;) } img.src = &apos;/xxx.png&apos; console.log(&apos;end&apos;) e.g.4 console.log(&apos;start&apos;) document.getElementById(&apos;btn1&apos;).addEventListener(&apos;click&apos;, function () { alert(&apos;clicked&apos;) }) console.log(&apos;end&apos;) 单线程JS 在客户端运行的时候，只有一个线程可运行，因此想要同时干两件事儿是不可能的。这时候就需要异步。单线程碰到异步代码就把异步代码放在一边，按顺序执行完毕后，再执行异步代码。这样就避免了阻塞。如果没有异步，只能同步干。当前面的代码需要花费较长时间时，后面的代码只能干等着。异步和单线程的关系简单来讲就是这样。 JS-Web-APIJS基础知识一般的“JS基础知识”也叫做“ES基础知识”，其实是最基础的语法知识，它包含的内容： 变量类型和计算 原型和原型链 闭包和作用域 异步和单线程 其他（如日期、Math、各种常用API） 这些知识如果从初学者看来，或者只从表面理解，对我们日常工作根本没什么作用。此前讲过，JS基础语法内置的函数有Object、Array、Boolean、Number、String、Function、Date、RegExp、Error，另外还有JSON、Math等常用的对象。但是拿到这些东西之后，貌似什么都干不了，连在网页中打印或者弹出一个提示都不能做。 但它是一个基础，越用JS你就越能发现。 JS-Web-API貌似之前的知识什么都干不了，但是浏览器有它的处理方式。 此前的JS基础知识（或者ES基础知识）是依据ECMA-262标准来制定的，浏览器会遵循这个标准，所以在浏览器中使用此前讲过的变量、原型、闭包、异步都是没有问题的。 在此基础之上，浏览器还得让JS参与更多的事情，即让开发者能通过JS操作网页的各个地方，因此浏览器需要为JS在使用这些基础知识的基础上，再开发新的能力。而这些能力就需要遵循 W3C 的标准。 W3C 规定了很多内容，例如 html 规则、css 规则、JS 接口的规则，而和 JS 相关的并且面试过程中经常出现的有： DOM 操作 BOM 操作 事件绑定 ajax 请求（包括 http 协议） 存储 那W3C是如何规定的，以及浏览器又是如何执行的呢。举例来说，要在页面弹框就需要alert(‘123’)，它写全了就是window.alert(‘123’)，那么浏览器需要做： 定义一个window全局变量 window是一个对象，给它定义一个alert属性，属性值是一个函数（该函数可以调起浏览器的弹框） 当然，window对象上有非常多的属性，这些都是浏览器给它赋值上的，当然开发者也可以对它进行扩展（符合对象的特性，可自由扩展属性）。 再举一个例子，根据id获取一个元素是document.getElementById(‘id’)，那么浏览器需要做： 定义一个document全局变量 给它定义一个getElementById的属性，属性值是一个方法 但是，W3C 没有规定任何语法的东西，什么变量类型、原型、作用域、异步，它都不管。它只管定义一些可以在浏览器中用于 JS 操作页面的 API 和对象。 最后，回过头来问一句，对于所有的 JS 来说（不是光考虑基础知识层面），它内置的全局变量有哪些？这个问题我们现在可能回答不全面，但是我们至少知道，除了之前讲过的那些，还有window、document这两个，其实还有其他的很多很多个，但是现在都不用管。而且，以后只要是遇到我们没有定义，就直接拿来用的全局变量，那肯定就是浏览器内置的JS全局变量。例如navigator.userAgent 总结：常说的JS（或浏览器中执行的JS）=JS基础知识（ECMA262标准）+JS-Web-API（W3C标准） DOM解释讲DOM先从html讲起，讲html先从XML讲起。XML是一种可扩展的标记语言，所谓可扩展就是它可以描述任何结构化的数据，从数据结构上讲，它是一棵树。参见例1. 代码片段 e.g.1 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt; &lt;other&gt; &lt;a&gt;&lt;/a&gt; &lt;b&gt;&lt;/b&gt; &lt;/other&gt; &lt;/note&gt; HTML是一个有既定标签标准的XML格式（其实就是XML的分支），标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一棵树。参见例2. 代码片段 e.g.2 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;this is p&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 我们开发完的html代码会保存到一个文档中（一般以.html或者.htm结尾），文档放在服务器上，浏览器请求服务器，这个文档被返回。因此，最终浏览器拿到的是一个文档而已，文档的内容就是html格式的代码。 但是浏览器要把这个文档中的html按照标准渲染成一个页面，此时浏览器就需要将这堆代码处理成自己能理解的东西，也得处理成JS能理解的东西，因为还得允许JS修改页面内容。 所以，DOM就是浏览器把拿到的html代码，结构化成一个浏览器能识别且JS能操作的模型。通俗讲，浏览器把html转变成DOM，html是一棵树，DOM也是一棵树。先从JS着手，即可以粗略地认为DOM就是JS能识别的html结构，一个普通的JS对象或者数组。 DOM 节点操作获取 DOM 节点var div1 = document.getElementById(&apos;div1&apos;) // 元素 var divList = document.getElementsByTagName(&apos;div&apos;) // 集合 console.log(divList.length) console.log(divList[0]) var containerList = document.getElementsByClassName(&apos;.container&apos;) // 集合 var pList = document.querySelectorAll(&apos;p&apos;) // 集合prototypeDOM节点就是一个JS对象，它符合之前讲述的对象的特征————可扩展属性。property 的获取和修改，是直接改变 JS 对象，是对JS对象而言的。 var pList = document.querySelectorAll(&apos;p&apos;) var p = pList[0] console.log(p.style.width) // 获取样式 p.style.width = &apos;100px&apos; // 修改样式 console.log(p.className) // 获取 class p.className = &apos;p1&apos; // 修改 class // 获取 nodeName 和 nodeType console.log(p.nodeName) console.log(p.nodeType)AttributeAttibute是修改html标签的属性。与property有很大的区别。 var pList = document.querySelectorAll(&apos;p&apos;) var p = pList[0] p.getAttribute(&apos;data-name&apos;) p.setAttribute(&apos;data-name&apos;, &apos;imooc&apos;) p.getAttribute(&apos;style&apos;) p.setAttribute(&apos;style&apos;, &apos;font-size:30px;&apos;)DOM 树操作新增节点var div1 = document.getElementById(&apos;div1&apos;) // 添加新节点 var p1 = document.createElement(&apos;p&apos;) p1.innerHTML = &apos;this is p1&apos; div1.appendChild(p1) // 添加新创建的元素 // 移动已有节点 var p2 = document.getElementById(&apos;p2&apos;) div1.appendChild(p2)获取父元素var div1 = document.getElementById(&apos;div1&apos;) var parent = div1.parentElement获取子元素var div1 = document.getElementById(&apos;div1&apos;) var child = div1.childNodes删除节点var div1 = document.getElementById(&apos;div1&apos;) var child = div1.childNodes div1.removeChild(child[0])还有其他操作的API，例如获取前一个节点、获取后一个节点等，但是面试过程中经常考到的就是上面几个。 BOMBOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取。包含的对象就是一堆非常简单粗暴的API。常用的几个如下： navigator screen location history 代码片段 e.g.1 // navigator var ua = navigator.userAgent var isChrome = ua.indexOf(&apos;Chrome&apos;) console.log(isChrome) // screen console.log(screen.width) console.log(screen.height) // location let url = https://www.baidu.com/index.html?keyword=’hehe’&amp;id=233#m=100 console.log(location.href) console.log(location.protocol) // https: console.log(location.host) // www.baidu.com console.log(location.pathname) // index.html console.log(location.search) // keyword=’hehe’&amp;id=233 console.log(location.hash) // #m=100 // history history.back() history.forward() 事件事件绑定行内绑定（DOM0级事件处理程序）：虽然可以完成需要的功能 但其把结构+样式+行为都绑定在同一个标签中不利于后期维护。 代码片段 e.g.1 &lt;div onclick=fn()&gt;hehe&lt;/div&gt; &lt;script&gt; function fn() { console.log(233); } &lt;/script&gt; 动态绑定（DOM0级事件处理程序）：将一个函数赋值给一个事件处理程序属性，简单且具有跨浏览器的优势。 行内绑定与动态绑定的区别： 行内绑定中，其事件处理中的this指向了全局window对象 动态绑定中，其事件处理中的this指向了当前正在操作的dom对象 代码片段 e.g.2 &lt;div id=&quot;box&quot;&gt;hehe&lt;/div&gt; document.getElementById(&apos;box&apos;).onclick = function () {console.log(233);} 事件监听（DOM2级事件处理程序）：和DOM0级事件处理程序的优势：可以添加多个事件处理程序，且DOM0级事件会被覆盖，DOM2级事件不会被覆盖。 addEventListener()：添加事件removeEventListener()：删除事件 接收三个参数：1、要处理的事件名2、作为事件处理程序的函数3、一个布尔值，默认为false。(true为在捕获阶段调用事件处理程序 false为在冒泡阶段调用事件处理程序) 代码片段 e.g.3 &lt;div id=&quot;box&quot;&gt;hehe&lt;/div&gt; document.getElementById(&apos;box&apos;).addEventListener(&apos;click&apos;, function () { console.log(111); }) 事件代理事件代理，由父元素代理子元素的事件，其实利用的是冒泡机制。自定义一个事件绑定函数。如例1. 自定义一个事件代理函数。如例2.例2中bindEvent方法对后两个参数做了调整，第三个参数可选。当只有三个参数时，只是普通的绑定事件函数，此时fn为null，将selector赋值给fn即可避免报错，此时，直接执行回调函数即可。当有四个参数时，if (target.matches(selector))判断传入的selector是否与触发事件的元素相等，相等就表示要代理这个元素的事件，然后执行回调函数，利用call改变this指向，并将e作为参数传出去，这样， bindEvent(div1, ‘click’, ‘p’, function (e) {console.log(this.innerHTML)})中的this才能指向触发事件的元素，也就是this才能指向p，并且能使用e参数。 代码片段 e.g.1 &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;激活&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;取消1&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;取消2&lt;/p&gt; &lt;p id=&quot;p4&quot;&gt;取消3&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;p id=&quot;p5&quot;&gt;取消4&lt;/p&gt; &lt;p id=&quot;p6&quot;&gt;取消5&lt;/p&gt; &lt;/div&gt; function bindEvent(elem, type, fn) { elem.addEventListener(type,fn) } let p = document.getElementById(&apos;p1&apos;) bindEvent(p, &apos;click&apos;, function (e) { console.log(p.innerHTML) }) e.g.2 &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;激活&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;取消1&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;取消2&lt;/p&gt; &lt;p id=&quot;p4&quot;&gt;取消3&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;p id=&quot;p5&quot;&gt;取消4&lt;/p&gt; &lt;p id=&quot;p6&quot;&gt;取消5&lt;/p&gt; &lt;/div&gt; function bindEvent(elem, type, selector, fn) { if (fn == null) { fn = selector selector = null } elem.addEventListener(type, function (e) { var target if (selector) { target = e.target if (target.match(selector)) { fn.call(target, e) } } else { fn(e) } }) } var div1 = document.getElementById(&apos;div1&apos;) // 使用代理 // bindEvent(div1, &apos;click&apos;, &apos;p&apos;, function (e) { // console.log(this.innerHTML) // }) // 不用代理 var p = document.getElementById(&apos;p1&apos;) bindEvent(div1, &apos;click&apos;, function (e) { console.log(p.innerHTML) }) AJAX基本AJAX=Asynchronous JavaScript and XML，异步的js和xml。原生js的AJAX请求。new XMLHttpRequest()创建一个请求实例。 open方法规定请求的类型、url及是否异步（true为异步，false为同步）。 send方法将请求发给服务器。可携带一个string类型的参数，可选。当用get方法时，将请求的参数添加在url中，如例1。用post方法时，将请求的参数放在send方法中，如例2. 当async=true时，要规定在响应处于onreadystatechange事件中的就绪状态时执行的函数。如例1。 当async=false时，不需要onreadystatechange函数，把代码放到send()语句后面即可。 代码片段 e.g.1 var xhr = new XMLHttpRequest() xhr.open(&quot;GET&quot;, &quot; /try/ajax/demo_get2.php?fname=Henry&amp;lname=Ford &quot;, true) xhr.onreadystatechange = function () { // 这里的函数异步执行，可参考之前 JS 基础中的异步模块 if (xhr.readyState == 4) { if (xhr.status == 200) { alert(xhr.responseText) } } } xhr.send(null) e.g.2 xhr.open(&quot;POST&quot;,&quot;/try/ajax/demo_post2.php&quot;,true); xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xhr.send(&quot;fname=Henry&amp;lname=Ford&quot;); xhr.readyState状态码0 - (未初始化）还没有调用send()方法1 -（载入）已调用send()方法，正在发送请求2 -（载入完成）send()方法执行完成，已经接收到全部响应内容3 -（交互）正在解析响应内容4 -（完成）响应内容解析完成，可以在客户端调用了 status状态码http 状态吗有 2xx 3xx 4xx 5xx 这几种，比较常用的有以下几种200 正常404 找不到资源5xx 服务器端出错了 responseText获得字符串形式的响应数据。 responseXML获得 XML 形式的响应数据。 跨域基本简单讲，CROS同源策略规定：自己的网站可以随便请求自己服务器的东西，但是因为安全问题，不能随便请求别人服务器的东西。请求别人服务器的东西，就算是跨域请求。同源策略不允许跨域请求。 跨域条件：协议、域名、端口，只要一个不同就算是跨域。一般http的端口是80，https的端口是443. 但是html中几个标签能逃避过同源策略：&lt;script src=&quot;xxx&quot;&gt;、&lt;img src=&quot;xxxx&quot;/&gt;、&lt;link href=&quot;xxxx&quot;&gt;，标签的src/href可以加载其他域的资源，不受同源策略限制。 因此，这是三个标签可以做一些特殊的事情。 img标签可以做打点统计，因为统计方并不一定是同域的，在讲解JS基础知识异步的时候有过代码示例。除了能跨域之外，img标签几乎没有浏览器兼容问题，它是一个非常古老的标签。 script标签和link标签可以使用CDN，CDN基本都是其他域的链接。 而且script标签还可以实现JSONP，能获取其他域接口的信息。但是请注意，所有的跨域请求方式，最终都需要信息提供方同意并做出相应的支持和改动才行，否则接收方是无法得到他们的信息的，浏览器是不允许的。 JSONP首先，要明白一个概念，例如访问http://www.baidu.com/classindex.html的时候，服务器端就不一定有一个classindex.html文件。服务器可以拿到这个请求，然后动态生成一个文件，然后返回。 同理，&lt;script src=&quot;http://www.bdiu.com/api.js&quot;&gt;也不一定加载一个服务器端的静态文件，服务器也可以动态生成文件并返回。例1中，当script标签请求到了api.js时，就会执行api.js的代码，api.js就是调用callback函数并传递参数，这个参数就是本地向外部请求的需要的数据。在本地中callback函数是暴露在全局作用域下的，此时就会输出接收到的data。整个过程就是，在本地中定义函数，在外部中传参并调用函数，函数一旦调用，本地就能接收到传递的参数。JSONP的缺点就是只能发送get请求。 代码片段 e.g. //请求的外部api.js内容： callback({x:100, y:200}) //本地代码： &lt;script&gt; function callback (data) { console.log(data) // 这是跨域得到的信息 } &lt;/script&gt; &lt;script src=&quot;http://www.bdiu.com/api.js&quot;&gt; 跨域资源共享CORS通过服务器端设置http header来控制跨域访问权限。 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;http://www.baidu.com&quot;);//第二个参数填写允许跨域的域名称，不建议直接写&quot;*&quot; response.setHeader(&quot;Access-Control-Allow-Headers&quot;,&quot;Content-Type,X-Requested-With&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);// 接收跨域的cookie数组的高阶函数forEach()forEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。forEach()常用于遍历数组，因此，传入的函数不需要返回值。 代码片段 e.g. var arr = [&apos;Apple&apos;, &apos;pear&apos;, &apos;orange&apos;]; arr.forEach(console.log); =&gt; Apple pear orange map()为数组中的所有元素依次执行方法。返回一个新数组。 array.map(function(currentValue,index,arr), thisValue)function：必须。函数，数组中的每个元素都会执行这个函数currentValue：必须。当前元素的值index：可选。当前元素的索引值arr：可选。当前元素属于的数组对象thisValue：可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。如果省略了 thisValue ，或者传入 null、undefined，那么回调函数的 this 为全局对象。 代码片段 e.g. function pow(x) { return x * x; } var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] console.log(results); =&gt; 1,4,9,16,25,36,49,64,81 reduce()Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算。返回计算结果。 array.reduce(function(total, currentValue, currentIndex, arr), initialValue)function：必须。函数，数组中的每个元素都会执行这个函数total：必需。初始值, 或者计算结束后的返回值。currentValue：必须。当前元素的值currentIndex：可选。当前元素的索引值arr：可选。当前元素属于的数组对象initialValue：可选。传递给函数的初始值 代码片段 e.g. var arr = [1, 3, 5, 7, 9]; arr.reduce(function (x, y) { return x + y; }); =&gt;25 filter()对数组所有元素执行方法，然后根据返回值是true还是false决定保留还是丢弃该元素，就是返回符合条件的元素。 array.filter(function(currentValue,index,arr), thisValue)function：必须。函数，数组中的每个元素都会执行这个函数currentValue：必须。当前元素的值index：可选。当前元素的索引值arr：可选。当前元素属于的数组对象thisValue：可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。如果省略了 thisValue ，”this” 的值为 “undefined” 代码片段 e.g. var arr = [1, 2, 4, 5, 6, 9, 10, 15]; var r = arr.filter(function (x) { return x % 2 !== 0; }); =&gt; [1, 5, 9, 15] sort()对数组进行排序操作。默认的排序规则会把40排在5前面，对于这样的需要通过函数作为参数来使用。对数组的引用。请注意，数组在原数组上进行排序，不生成副本，修改原来的数组。 array.sort(sortfunction)sortfunction：可选。规定排序顺序。必须是函数。 代码片段 e.g.1 var arr = [10, 20, 1, 2]; arr.sort(function (x, y) { if (x &lt; y) { return -1; } if (x &gt; y) { return 1; } return 0; }); console.log(arr); =&gt; [1, 2, 10, 20] e.g.2 var points = [40,100,1,5,25,10]; points.sort(function(a,b){return a-b}); =&gt; 1,5,10,25,40,100 默认情况下，对字符串排序，是按照ASCII的大小比较的，排序应该忽略大小写，按照字母序排序。 e.g.3 var arr = [&apos;Google&apos;, &apos;apple&apos;, &apos;Microsoft&apos;]; arr.sort(function (s1, s2) { x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) { return -1; } if (x1 &gt; x2) { return 1; } return 0; }); =&gt; [&apos;apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;] every()可以判断数组的所有元素是否满足指定条件。如果检测到数组中有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。如果所有元素都满足条件，则返回 true。 array.every(function(currentValue,index,arr), thisValue)function：必须。函数，数组中的每个元素都会执行这个函数currentValue：必须。当前元素的值index：可选。当前元素的索引值arr：可选。当前元素属于的数组对象thisValue：可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。如果省略了 thisValue ，”this” 的值为 “undefined” 代码片段 e.g. var arr = [&apos;Apple&apos;, &apos;pear&apos;, &apos;orange&apos;]; console.log(arr.every(function (s) { return s.length &gt; 0; })); // true, 因为每个元素都满足s.length&gt;0 console.log(arr.every(function (s) { return s.toLowerCase() === s; })); // false, 因为不是每个元素都全部是小写 find()用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined。不改变原数组。 代码片段 e.g. var arr = [&apos;Apple&apos;, &apos;pear&apos;, &apos;orange&apos;]; console.log(arr.find(function (s) { return s.toLowerCase() === s; })); // &apos;pear&apos;, 因为pear全部是小写 console.log(arr.find(function (s) { return s.toUpperCase() === s; })); // undefined, 因为没有全部是大写的元素 findIndex()findIndex()和find()类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，如果没有找到，返回-1。 代码片段 e.g. var arr = [&apos;Apple&apos;, &apos;pear&apos;, &apos;orange&apos;]; console.log(arr.findIndex(function (s) { return s.toLowerCase() === s; })); // 1, 因为&apos;pear&apos;的索引是1 console.log(arr.findIndex(function (s) { return s.toUpperCase() === s; })); // -1","categories":[{"name":"js","slug":"js","permalink":"https://lifenobody.github.io/categories/js/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://lifenobody.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"js","slug":"js","permalink":"https://lifenobody.github.io/tags/js/"}]},{"title":"Vue基础","slug":"Vue基础","date":"2020-07-01T06:22:39.000Z","updated":"2020-07-06T14:21:16.136Z","comments":true,"path":"2020/07/01/Vue基础/","link":"","permalink":"https://lifenobody.github.io/2020/07/01/Vue%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Vue项目目录介绍build文件夹：构建脚本目录 build.js:生产环境构建脚本 check-version.js:版本检查（node、npm） logo.png:logo图片 util.js:构建相关工具方法 vue-loader.conf.js:css加载器配置 webpack.base.conf.js:webpack基础配置 webpack.dev.conf.js:webpack开发环境配置 webpack.prod.conf.js:webpack生产环境配置config文件夹：项目配置 dev.env.js:开发环境变量 index.js:项目配置文件 prod.env.js:生产环境变量node_modules文件夹：依赖的模块src文件夹：项目源码目录 main.js:入口js文件 App.vue:根组件 components文件夹：公共组件目录 assets文件夹：资源目录，这里的资源会被webpack构建static文件夹：纯静态资源.babelrc:babel配置.editorconfig:editor配置index.html:index.html模板.postcssrc.js:postcss配置package.json:npm包配置文件，定义项目的npm脚本、依赖包等package-lock.json:记录依赖包的依赖版本号README:项目的说明文档，markdown格式 MVP模式与MVVM模式Model-View-Presenter，Model模型处理数据，View视图处理显示数据，Presenter控制器处理业务逻辑。在MVP中View并不直接使用Model，它们之间的通信是通过Presenter来进行的，所有的交互都发生在Presenter内部。 图MVP模式 例1是个典型的MVP模式，此处由于数据处理极少，Model的作用不大，但是就一般而言，View与Model的交互要通过Presenter，Presenter是整个模式的核心。View发起一个事件，Presenter执行事件，要么修改Model处理数据，要么修改View处理显示。可以很明显地看到有很多的代码是操作DOM的，通过操作DOM来控制View。 代码片段 1234567891011121314151617181920212223242526272829e.g.1&lt;body&gt; &lt;div&gt; &lt;input id&#x3D;&quot;input&quot; type&#x3D;&quot;text&quot; &#x2F;&gt; &lt;button id&#x3D;&quot;btn&quot;&gt;提交&lt;&#x2F;button&gt; &lt;ul id&#x3D;&quot;list&quot;&gt;&lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;script&gt; function Page() &#123; &#125; $.extend(Page.prototype, &#123; init: function () &#123; this.bindEvents() &#125;, bindEvents: function () &#123; var btn &#x3D; $(&#39;#btn&#39;); btn.on(&#39;click&#39;, $.proxy(this.handleBtnClick, this)) &#125;, handleBtnClick: function () &#123; var inputElem &#x3D; $(&quot;#input&quot;); var inputValue &#x3D; inputElem.val(); var ulElem &#x3D; $(&quot;#list&quot;); ulElem.append(&#39;&lt;li&gt;&#39; + inputValue + &#39;&lt;&#x2F;li&gt;&#39;); inputElem.val(&#39;&#39;); &#125; &#125;) var page &#x3D; new Page(); page.init(); &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; Model-View-ViewModel。它本质上就是MVC的改进版。MVVM就是将其中的View的状态和行为抽象化，将视图和业务逻辑分开。Model模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。View视图是用户在屏幕上看到的结构、布局和外观。ViewModel视图模型是暴露公共属性和命令的视图的抽象。 MVVM没有MVC模式的Controller，也没有MVP模式的Presenter，只有一个ViewModel。ViewModel在View和Model之间进行通信。ViewModel可以取出Model的数据同时处理View中需要显示数据的部分。在这种模式下，Model成为核心，View和Model没有直接的联系，而是通过ViewModel进行交互，Model和ViewModel之间的交互是双向的，因此View数据的变化会同步到Model中，而Model数据的变化也会立即反应到View上。 图MVVM模式 例2是个MVVM模式，基本没有操作DOM的代码，这就节省了DOM操作。主要依靠数据的改变而改变View。当改变数据时，Vue会监听数据的变化，并自动改变View。 代码片段 12345678910111213141516171819202122232425e.g.2&lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;inputValue&quot; &#x2F;&gt; &lt;button v-on:click&#x3D;&quot;handleBtnClick&quot;&gt;提交&lt;&#x2F;button&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;item in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;script&gt; var app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; list: [], inputValue: &#39;&#39; &#125;, methods: &#123; handleBtnClick: function () &#123; this.list.push(this.inputValue) this.inputValue &#x3D; &#39;&#39; &#125; &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 生命周期函数简单讲，生命周期函数就是Vue实例在某一时间点自动执行的函数。Vue的生命周期函数一共有11个，beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、activated、deactivated、beforeDestroy、destroyed、errorCaptured。这些生命周期函数不放在methods下，而是直接放在Vue实例对象下。例1中展示了8个。 代码片段 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt; &lt;script&gt; var vm &#x3D; new Vue(&#123; el: &quot;#app&quot;, template: &quot;&lt;div&gt;&#123;&#123;test&#125;&#125;&lt;&#x2F;div&gt;&quot;, data: &#123; test: &quot;hello world&quot; &#125;, beforeCreate: function () &#123; console.log(&quot;beforeCreate&quot;); &#125;, created: function () &#123; console.log(&quot;created&quot;); &#125;, beforeMount: function () &#123; console.log(this.$el); console.log(&quot;beforeMount&quot;); &#125;, mounted: function () &#123; console.log(this.$el); console.log(&quot;mounted&quot;); &#125;, beforeDestroy: function () &#123; console.log(&quot;beforeDestroy&quot;); &#125;, destroyed: function () &#123; console.log(&quot;destroyed&quot;); &#125;, beforeUpdate: function () &#123; console.log(&quot;beforeUpdate&quot;); &#125;, updated: function () &#123; console.log(&quot;updated&quot;); &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; VueAPIis有的标签会限制其内部标签，如ul、ol、table、select等内部是固定的标签，不可含有其他标签。 如果有例1的需求，这个自定义组件会被作为无效的内容提升到外部，并导致最终渲染结果出错。 此时可利用is属性。如例2.表面上ul里面是li，实际上渲染的是组件的模板内容，即渲染p标签。is属性合法地用com组件代替li，这样就不会报错。 代码片段 123456789101112e.g.1&lt;ul&gt; &lt;com&gt;&lt;&#x2F;com&gt;&lt;&#x2F;ul&gt;e.g.2&lt;ul&gt; &lt;li is&#x3D;&quot;com&quot;&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;Vue.component(&#39;counter&#39;,&#123; template: &#39;&lt;p class&#x3D;&quot;hehe&quot;&gt;cccccc&lt;&#x2F;p&gt;&#39;&#125;) refref被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的$refs对象上。如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子组件上，引用就指向组件实例。当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。 关于ref注册时间，因为ref本身是作为渲染结果被创建的，在初始渲染的时候不能访问，它们还不存在！$refs 也不是响应式的，因此不应该试图用它在模板中做数据绑定。 ref=”p”表示将p标签绑定到名为p的变量上。ref=”child”表示将子组件绑定到名为child的变量上。在父组件上用this.$refs.p找到DOM元素，用this.$refs.child找到子组件实例。 代码片段 12345e.g.1&lt;p ref&#x3D;&quot;p&quot;&gt;hello&lt;&#x2F;p&gt;e.g.2&lt;child-component ref&#x3D;&quot;child&quot;&gt;&lt;&#x2F;child-component&gt; set方法可以调用set方法进行数据的修改，对数据的修改会实时反映到页面中。 基本格式，Vue.set(target, propertyName/index, value)。 Vue.set()===vm.$set()。 对象上使用set，Vue.set(obj,’name’,’zhangsan’) 数组上使用set，Vue.set(obj,2,’zhangsan’) 指令v-once直接在标签上写v-once即可表示该元素或组件只在初始化时渲染一次。即使重新渲染，元素或组件及其子节点都被当作静态内容并跳过，不会再被修改。 代码片段 12345678910111213&lt;!-- 单个元素 --&gt;&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;&#x2F;span&gt;&lt;!-- 有子元素 --&gt;&lt;div v-once&gt; &lt;h1&gt;comment&lt;&#x2F;h1&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;!-- 组件 --&gt;&lt;my-component v-once :comment&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;my-component&gt;&lt;!-- &#96;v-for&#96; 指令--&gt;&lt;ul&gt; &lt;li v-for&#x3D;&quot;i in list&quot; v-once&gt;&#123;&#123;i&#125;&#125;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; Vue实例通过new Vue()来创建一个Vue实例，el将实例绑定在某个元素上，在Vue中做的任何操作产生的影响都只在该元素以内。创建的子组件也可算作是一个实例。Vue语法规定以$开头去访问Vue实例的属性和方法。$destroy()销毁Vue实例主要是指清除数据间的双向绑定，绑定的事件并没有被销毁，可以再次被触发。 代码片段 12345678910111213141516171819202122232425e.g.&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt; &lt;div @click&#x3D;&quot;handleClick&quot;&gt; &#123;&#123;message&#125;&#125; &lt;&#x2F;div&gt; &lt;item&gt;&lt;&#x2F;item&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.component(&#39;item&#39;, &#123; template: &#39;&lt;div&gt;hello item&lt;&#x2F;div&gt;&#39; &#125;) var vm &#x3D; new Vue(&#123; el: &#39;#root&#39;, data: &#123; message: &#39;hello world&#39; &#125;, methods: &#123; handleClick: function () &#123; alert(&quot;hello&quot;) &#125; &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 组件基本简单讲就是将若干功能区单独包装成一个区块，这样在某处用到该功能的时候，不需要再编写，直接引用即可。 组件是可复用的Vue实例，每用一次就会有一个新的实例被创建，且数据不共享。只有根组件有el属性，其他的都一样。 代码片段 1234567891011121314151617181920212223242526272829303132333435363738394041e.g.1&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt; &lt;div&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;todoValue&quot; &#x2F;&gt; &lt;button @click&#x3D;&quot;handleBtnClick&quot;&gt;提交&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;ul&gt; &lt;todo-item v-bind:content&#x3D;&quot;item&quot; v-for&#x3D;&quot;item in list&quot;&gt;&lt;&#x2F;todo-item&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;script&gt; var TodoItem &#x3D; &#123; props: [&#39;content&#39;], template: &quot;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;&#x2F;li&gt;&quot; &#125; var app &#x3D; new Vue(&#123; el: &quot;#root&quot;, components: &#123; TodoItem: TodoItem &#125;, data: &#123; todoValue: &quot;&quot;, list: [] &#125;, methods: &#123; handleBtnClick: function () &#123; this.list.push(this.todoValue) this.todoValue &#x3D; &quot;&quot; &#125; &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;e.g.2&lt;div id&#x3D;&quot;components-demo&quot;&gt; &lt;button-counter&gt;&lt;&#x2F;button-counter&gt; &lt;button-counter&gt;&lt;&#x2F;button-counter&gt; &lt;button-counter&gt;&lt;&#x2F;button-counter&gt;&lt;&#x2F;div&gt; 子组件的data根组件中的data定义为对象，子组件中的data必须定义为函数且返回一个对象，子组件的数据定义在这个对象中。因为子组件可能复用，为了每个组件都维护自己独立的数据，data定义为函数后，每个函数返回一个对象，对象里的数据就存在不同的地方，就可在复用时避免数据的交叉冲突。 代码片段 123456789101112e.g.1Vue.component(&#39;com&#39;,&#123; data:function()&#123; return &#123;&#125;&#125;&#125;)e.g.2&lt;ul&gt; &lt;li is&#x3D;&quot;com&quot;&gt;&lt;&#x2F;li&gt; &lt;li is&#x3D;&quot;com&quot;&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 父子组件传值Vue规定单项数据流，父组件可向子组件传递数据，子组件对接收的数据只能读，不能随意修改。 父组件给子组件传数据是靠给子组件自定义属性，通过属性将数据传递给子组件。而子组件想要修改父组件的数据，得父组件定义出修改方法，再让子组件触发这个方法，子组件不能直接修改传递过来的数据。 例1，利用v-bind绑定动态数据，如:content=”item”表示给子组件自定义一个content属性，content属性与item数据绑定，这样，每个item数据都会通过content属性传递给子组件。子组件所有的属性都由props来接管，props是个数组，形如props: [‘content’, ‘index’]，这样props就接管了子组件的所有属性，子组件就接收到了来自父组件的数据。 为了实现点击元素就删除自己，本着数据驱动的思想，只要修改父组件的lsit值即可删除li标签。但是li是子组件创建的，Vue为了防止数据出错，子组件不能直接修改父组件的数据，这样得靠父组件提供删除接口，然后子组件调用删除接口即可。@delete=”handleItemDelete”表示每个子组件都绑定了自定义事件delete，当子组件触发delete事件时，父组件就执行handleItemDelete方法。子组件的this.$emit(“delete”, this.index);表示触发delete事件，并将index作为参数传递给父组件。 代码片段 123456789101112131415161718192021222324252627282930313233343536373839404142e.g.1&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt; &lt;div&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;todoValue&quot; &#x2F;&gt; &lt;button @click&#x3D;&quot;handleBtnClick&quot;&gt;提交&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;ul&gt; &lt;todo-item :content&#x3D;&quot;item&quot; :index&#x3D;&quot;index&quot; v-for&#x3D;&quot;(item, index) in list&quot; @delete&#x3D;&quot;handleItemDelete&quot;&gt;&lt;&#x2F;todo-item&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;script&gt; var TodoItem &#x3D; &#123; props: [&#39;content&#39;, &#39;index&#39;], template: &quot;&lt;li @click&#x3D;&#39;handleItemClick&#39;&gt;&#123;&#123;content&#125;&#125;&lt;&#x2F;li&gt;&quot;, methods: &#123; handleItemClick: function () &#123; this.$emit(&quot;delete&quot;, this.index); &#125; &#125; &#125; var app &#x3D; new Vue(&#123; el: &quot;#root&quot;, components: &#123; TodoItem: TodoItem &#125;, data: &#123; todoValue: &quot;&quot;, list: [] &#125;, methods: &#123; handleBtnClick: function () &#123; this.list.push(this.todoValue); this.todoValue &#x3D; &quot;&quot;; &#125;, handleItemDelete: function (index) &#123; this.list.splice(index, 1); &#125; &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 循环与组件见循环渲染中的循环组件。 组件参数校验子组件不能随意修改父组件传递来的数据，但是可对数据进行约束校验。此时porps不再赋值为数组，而是对象。简单的数据类型校验如例1，规定content只能是String类型的，如果传递来的数据不是String类型的就会报警告。例2规定content类型只能是String和Number类型的。复杂点的校验如例3，规定了类型、必须、默认值和自定义校验器。 代码片段 12345678910111213141516171819202122232425262728293031323334e.g.1props:&#123; content:String&#125;e.g.2props:&#123; content:[String,Number]&#125;e.g.3&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt; &lt;child content&#x3D;&quot;hell&quot;&gt;&lt;&#x2F;child&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.component(&#39;child&#39;, &#123; props: &#123; content: &#123; type: String,&#x2F;&#x2F; 类型 required: false,&#x2F;&#x2F; 必须 default: &#39;default value&#39;,&#x2F;&#x2F; 默认值 validator: function (value) &#123;&#x2F;&#x2F; 自定义校验器，需是函数 return (value.length &gt; 5) &#125; &#125; &#125;, template: &#39;&lt;div&gt;hello&lt;&#x2F;div&gt;&#39; &#125;) var vm &#x3D; new Vue(&#123; el: &#39;#root&#39; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; props特性与非props特性props特性意为父组件通过自定义属性给子组件传递数据，子组件要用props属性来接收这些数据，接收后才能使用这些数据。如例1. 非props特性意为父组件通过自定义属性给子组件传递数据，子组件没有用props属性来接收这些数据，那么子组件就不能使用这些数据。父组件给子组件的自定义属性就会显示在子组件最外层标签上。如例2. 代码片段 1234567891011121314151617181920212223242526272829303132333435363738e.g.1&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt; &lt;child content&#x3D;&quot;hell&quot;&gt;&lt;&#x2F;child&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.component(&#39;child&#39;, &#123; props：[content] template: &#39;&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;&#x2F;div&gt;&#39; &#125;) var vm &#x3D; new Vue(&#123; el: &#39;#root&#39; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&#x2F;&#x2F; 最终渲染为&lt;div id&#x3D;&quot;root&quot;&gt; &lt;div&gt;hell&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;e.g.2&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt; &lt;child content&#x3D;&quot;hell&quot;&gt;&lt;&#x2F;child&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.component(&#39;child&#39;, &#123; template: &#39;&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;&#x2F;div&gt;&#39; &#125;) var vm &#x3D; new Vue(&#123; el: &#39;#root&#39; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&#x2F;&#x2F; 最终渲染为&lt;div id&#x3D;&quot;root&quot;&gt; &lt;div content&#x3D;&quot;hell&quot;&gt;&#123;&#123;content&#125;&#125;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; 给子组件绑定原生事件如例1，想触发子组件的click事件，但是这样写只会被认为是名为click的自定义事件，点击并不会有效果。要想实现效果，做法如例2，要触发父组件的事件。 但是，有个简单方法，此时加.native修饰符即可。如例1. 代码片段 123456789101112131415161718192021222324252627e.g.1&lt;child @click&#x3D;&quot;handleClick&quot;&gt;&lt;&#x2F;child&gt;&lt;child @click.native&#x3D;&quot;handleClick&quot;&gt;&lt;&#x2F;child&gt;e.g.2&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt; &lt;child @click&#x3D;&quot;handleClick&quot;&gt;&lt;&#x2F;child&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.component(&#39;child&#39;, &#123; template: &#39;&lt;div&gt;Child&lt;&#x2F;div&gt;&#39;, methods: &#123; handleClick: function () &#123; console.log(&#39;child click&#39;); &#125; &#125; &#125;) var vm &#x3D; new Vue(&#123; el: &#39;#root&#39;, methods: &#123; handleClick: function () &#123; console.log(&#39;click&#39;); &#125; &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 非父子组件传值父子组件可用props和自定义事件进行传值与修改。但是非父子组件，如祖孙、兄弟之间传值的话不能这样做。这时，可用VueX，适合大型项目，当前只演示小案例，采用总线机制。 例1中，同个子组件复用两次，两次都传递不同的数据，想点击其中一个组件就改变另一个组件的值，很明显是兄弟组件间传值。在Vue的原型上定义一个名为bus的属性，因为是在Vue原型上定义，所以所有的Vue实例都有该属性。并创建一个Vue实例，将实例赋值给bus，此时，bus是Vue原型上的属性，也是一个Vue实例。this.bus.$emit(‘change’, this.myContent)这样写没问题，找到该组件的属性bus，并触发change事件，每次触发事件都会让页面重新渲染，每次渲染就会执行mounted函数，此时，页面的数据就发生改变。 代码片段 123456789101112131415161718192021222324252627282930313233e.g.1&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt; &lt;child content&#x3D;&quot;childOne&quot;&gt;&lt;&#x2F;child&gt; &lt;child content&#x3D;&quot;childTwo&quot;&gt;&lt;&#x2F;child&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.prototype.bus &#x3D; new Vue() Vue.component(&#39;child&#39;, &#123; props: [&#39;content&#39;], data: function () &#123; return &#123; myContent: this.content &#125; &#125;, template: &#39;&lt;div @click&#x3D;&quot;handleClick&quot;&gt;&#123;&#123;myContent&#125;&#125;&lt;&#x2F;div&gt;&#39;, methods: &#123; handleClick: function () &#123; this.bus.$emit(&#39;change&#39;, this.myContent) &#125; &#125;, mounted: function () &#123; var this_ &#x3D; this; this.bus.$on(&#39;change&#39;, function (content) &#123; this_.myContent &#x3D; content &#125;) &#125; &#125;) var vm &#x3D; new Vue(&#123; el: &quot;#root&quot; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 插槽通过插槽可以向子组件传递许多内容，如html标签、文本等。 匿名插槽在子组件中直接写入内容，然后在子组件中添加slot标签，slot标签会自动接收child标签之间的所有内容，如例1. 代码片段 12345678910111213141516171819e.g.1&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt; &lt;child&gt; &lt;h1&gt;hello&lt;&#x2F;h1&gt;&#x2F;&#x2F; 插槽内容 &lt;&#x2F;child&gt; &lt;&#x2F;div&gt; &lt;script&gt; var child &#x3D; &#123; template: &#39;&lt;div&gt;&lt;slot&gt;默认插槽的内容&lt;&#x2F;slot&gt;&lt;&#x2F;div&gt;&#39; &#125; var vm &#x3D; new Vue(&#123; components: &#123; child: child &#125;, el: &quot;#root&quot; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 具名插槽在子组件中传递许多不同的内容，要求在子组件的不同地方显示，此时可将slot命名，命名后可一一对应各自的内容。如例1。 代码片段 1234567891011121314151617181920212223242526e.g.1&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt; &lt;child&gt; &lt;h1 slot&#x3D;&quot;header&quot;&gt;header&lt;&#x2F;h1&gt; &lt;h1 slot&#x3D;&quot;footer&quot;&gt;footer&lt;&#x2F;h1&gt; &lt;&#x2F;child&gt; &lt;&#x2F;div&gt; &lt;script&gt; var child &#x3D; &#123; template: &#96;&lt;div&gt; &lt;slot name&#x3D;&quot;header&quot;&gt;&lt;&#x2F;slot&gt; &lt;div&gt; &lt;h2&gt;content&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; &lt;slot name&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&#96; &#125; var vm &#x3D; new Vue(&#123; components: &#123; child: child &#125;, el: &quot;#root&quot; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 插槽默认值不管是匿名插槽还是具名插槽，都可在slot标签中设置默认内容，如果在子组件调用时没有传递相关数据，那么将显示slot标签中的默认内容。 作用域插槽slot-scope属性能让插槽内容访问子组件中的数据。使用时必须用template。 template用slot-scope定义了一个自定义属性content，所以h1能访问到content。slot标签绑定了一个自定义属性str，将子组件内的数据list赋值给str。最后str被content接收，h1就访问到了子组件的数据。 代码片段 12345678910111213141516171819202122232425e.g.1&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt; &lt;child&gt; &lt;template slot-scope&#x3D;&quot;content&quot;&gt; &lt;h1&gt;&#123;&#123;content.str&#125;&#125;&lt;&#x2F;h1&gt; &lt;&#x2F;template&gt; &lt;&#x2F;child&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.component(&#39;child&#39;, &#123; data: function () &#123; return &#123; list: &#39;hehehehe&#39; &#125; &#125;, template: &#96;&lt;div&gt; &lt;slot :str&#x3D;list&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&#96; &#125;) var vm &#x3D; new Vue(&#123; el: &#39;#root&#39; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 动态组件利用&lt;component&gt;标签配合is属性即可把&lt;component&gt;标签渲染为对应的组件。 例2通过点击按钮切换不同的组件，很基础。改为例3利用&lt;component&gt;进行动态渲染，升级了。 代码片段 1234567891011121314151617181920212223242526272829303132333435363738e.g.1&lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt;&#x2F;&#x2F; 渲染为&lt;currentTabComponent&gt;&lt;&#x2F;currentTabComponent&gt;e.g.2&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt; &lt;child-one v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D;&#39;child-one&#39;&quot;&gt;&lt;&#x2F;child-one&gt; &lt;child-two v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D;&#39;child-two&#39;&quot;&gt;&lt;&#x2F;child-two&gt; &lt;button @click&#x3D;&quot;handleBtnClick&quot;&gt;change&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.component(&#39;child-one&#39;, &#123; template: &#39;&lt;div v-once&gt;child-one&lt;&#x2F;div&gt;&#39; &#125;) Vue.component(&#39;child-two&#39;, &#123; template: &#39;&lt;div v-once&gt;child-two&lt;&#x2F;div&gt;&#39; &#125;) var vm &#x3D; new Vue(&#123; el: &#39;#root&#39;, data: &#123; type: &#39;child-one&#39; &#125;, methods: &#123; handleBtnClick: function () &#123; this.type &#x3D; (this.type &#x3D;&#x3D;&#x3D; &#39;child-one&#39; ? &#39;child-two&#39; : &#39;child-one&#39;); &#125; &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;e.g.3&lt;div id&#x3D;&quot;root&quot;&gt; &lt;component :is&#x3D;&quot;type&quot;&gt;&lt;&#x2F;component&gt; &lt;button @click&#x3D;&quot;handleBtnClick&quot;&gt;change&lt;&#x2F;button&gt;&lt;&#x2F;div&gt; 模板语法简单讲几个，详见官方文档API。 文本插值数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值，将数据解释为普通文本。文本插值允许元素添加其他内容。例1会显示msg的值和hehe。 12e.g.1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;hehe呵呵&lt;&#x2F;span&gt; v-text同样地改变元素textContent，但是v-text的值会替换掉元素内的文本。例2只有msg的值，不会显示hehe。 12e.g.2&lt;span v-text&#x3D;&quot;msg&quot;&gt;hehe&lt;&#x2F;span&gt; v-html更新元素的innerHTML，使用这个指令会将绑定的值里的html标签解析出来，不会当作普通文本。例3会显示加粗的hehe，而不是像v-text和{{}}会显示&lt;h1&gt;hehe&lt;/h1&gt;。 123e.g.3msg:&lt;h1&gt;hehe&lt;&#x2F;h1&gt;&lt;span v-html&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;span&gt; 计算属性、方法与侦听器同一函数，在computed里称为计算属性，在methods里称为方法。 计算属性computed能够处理一些复杂的逻辑。 比较重要的一点就是它的缓存机制。当computed里面的属性没有发生变化时，computed是返回之前的结果，不会重新执行函数。例1中，当在控制台修改age时，页面会重新渲染，但是fullName方法并不会重新执行，computed利用缓存，直接返回之前的结果。 代码片段 1234567891011121314151617181920212223e.g.1&lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &#123;&#123;fullName&#125;&#125; &#123;&#123;age&#125;&#125; &lt;&#x2F;div&gt; &lt;script&gt; var vm &#x3D; new Vue(&#123; el: &quot;#app&quot;, data: &#123; firstName: &quot;Dell&quot;, lastName: &quot;Lee&quot;, age: 28 &#125;, computed: &#123; fullName: function() &#123; console.log(&quot;计算了一次&quot;); return this.firstName + &quot; &quot; + this.lastName &#125; &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 方法methods与computed一样能执行复杂的逻辑。 但是没有缓存机制，在页面重新渲染时，methods总会再次执行函数。例1在控制台修改age的值，页面刷新时就会执行fullName方法，比computed较耗性能。 代码片段 1234567891011121314151617181920212223e.g.1&lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &#123;&#123;fullName&#125;&#125; &#123;&#123;age&#125;&#125; &lt;&#x2F;div&gt; &lt;script&gt; var vm &#x3D; new Vue(&#123; el: &quot;#app&quot;, data: &#123; firstName: &quot;Dell&quot;, lastName: &quot;Lee&quot;, age: 28 &#125;, methods: &#123; fullName: function () &#123; console.log(&quot;计算了一次&quot;); return this.firstName + &quot; &quot; + this.lastName; &#125; &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 侦听器watch侦听器会监听数据变动，根据变动做出行动。 与computed一样有个缓存机制，但是在相同的条件下，代码量比computed多，见例1。还是推荐用computed。 代码片段 12345678910111213141516171819202122232425262728e.g.1&lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &#123;&#123;fullName&#125;&#125; &#123;&#123;age&#125;&#125; &lt;&#x2F;div&gt; &lt;script&gt; var vm &#x3D; new Vue(&#123; el: &quot;#app&quot;, data: &#123; firstName: &quot;Dell&quot;, lastName: &quot;Lee&quot;, fullName: &quot;Dell Lee&quot;, age: 28 &#125;, watch: &#123; firstName: function () &#123; console.log(&quot;计算了一次&quot;); this.fullName &#x3D; this.firstName + &quot; &quot; + this.lastName; &#125;, lastName: function () &#123; console.log(&quot;计算了一次&quot;); this.fullName &#x3D; this.firstName + &quot; &quot; + this.lastName; &#125; &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; computed的setter和gettercomputed默认只有getter，不过在需要的时候可以设置setter。 例4在控制台操作vm.fullName=&quot;Li San&quot;时，会调用fullName的set方法，firstName值和lastName值就会被修改，watch监听到这两个数据发生了变化，就会执行fullName的get方法，显示新的fullName值。 代码片段 123456789101112131415161718192021222324252627e.g.4&lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &#123;&#123;fullName&#125;&#125; &lt;&#x2F;div&gt; &lt;script&gt; var vm &#x3D; new Vue(&#123; el: &quot;#app&quot;, data: &#123; firstName: &quot;Dell&quot;, lastName: &quot;Lee&quot; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + &quot; &quot; + this.lastName &#125;, set: function (value) &#123; var arr &#x3D; value.split(&quot; &quot;); this.firstName &#x3D; arr[0]; this.lastName &#x3D; arr[1]; &#125; &#125; &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; class绑定用v-bind绑定class，只需要通过表达式计算出字符串结果即可。不仅可使用字符串，还能使用对象、数组。 对象语法例1表示active这个class存在与否将取决于数据isActive的真假。键是类名。 例2表示v-bind:class可以和class共用。同样的，绑定数据的class显示与否取决于isActive和hasError的真假。键是类名。 例3表示绑定的数据对象不必内联定义在模板里。classObject里直接定义了类名和与其对应的真假值。不太好像之前的动态修改。键是类名。 例4表示单击div即可切换文本颜色。 代码片段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051e.g.1&lt;div v-bind:class&#x3D;&quot;&#123; active: isActive &#125;&quot;&gt;&lt;&#x2F;div&gt;data: &#123; isActive: true&#125;e.g.2&lt;div class&#x3D;&quot;static&quot; v-bind:class&#x3D;&quot;&#123; active: isActive, &#39;text-danger&#39;: hasError &#125;&quot;&gt;&lt;&#x2F;div&gt;data: &#123; isActive: true, hasError: false&#125;e.g.3&lt;div v-bind:class&#x3D;&quot;classObject&quot;&gt;&lt;&#x2F;div&gt;data: &#123; classObject: &#123; active: true, &#39;text-danger&#39;: false &#125;&#125;e.g.4&lt;style&gt; .active:&#123; color:red;&#125;&lt;&#x2F;style&gt;&lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;div :class&#x3D;&quot;&#123;active:isActive&#125;&quot; @click&#x3D;&quot;handleDivClick&quot;&gt; Hello world &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script&gt; var vm &#x3D; new Vue(&#123; el: &quot;#app&quot;, data: &#123; isActive:false &#125;, methods: &#123; handleDivClick: function () &#123; this.isActive &#x3D; !this.isActive; &#125; &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 数组语法可以把一个数组传给v-bind:class，以应用一个class列表。数组中存储的是与类名相绑定的数据变量，不是类名，存类名的话就用不着v-bind:class了。 例5中用简单的三元运算符做了判断条件，数组里面存的还是变量，不是类名。 例6是例5的升级版，数组里可以使用对象语法。 代码片段 123456789101112e.g.5&lt;div v-bind:class&#x3D;&quot;[activeClass, errorClass]&quot;&gt;&lt;&#x2F;div&gt;data: &#123; activeClass: &#39;active&#39;, errorClass: &#39;text-danger&#39;&#125;e.g.6&lt;div v-bind:class&#x3D;&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;&#x2F;div&gt;e.g.7&lt;div v-bind:class&#x3D;&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;&#x2F;div&gt; 用在组件上当在一个自定义组件上使用class时，这些class将被添加到该组件的根元素上面。这个元素上已经存在的class不会被覆盖。 代码片段 123456789e.g.8&#x2F;&#x2F; 自定义组件，p标签就是这个组件的根元素，已有foo和bar两个类名。Vue.component(&#39;my-component&#39;, &#123; template: &#39;&lt;p class&#x3D;&quot;foo bar&quot;&gt;Hi&lt;&#x2F;p&gt;&#39;&#125;)&#x2F;&#x2F; 引用组件的时候，在组件上定义类名，也可用数据绑定的类名&lt;my-component class&#x3D;&quot;baz boo&quot; v-bind:class&#x3D;&quot;&#123; active: isActive &#125;&quot;&gt;&lt;&#x2F;my-component&gt;&#x2F;&#x2F; 最终渲染结果，组件上的类名会被添加到组件的根元素上&lt;p class&#x3D;&quot;foo bar baz boo&quot;&gt;Hi&lt;&#x2F;p&gt; style绑定v-bind:style的对象语法十分直观，看着非常像CSS，但其实是一个JavaScript对象。CSS property名可以用驼峰式(camelCase)或短横线分隔(kebab-case，记得用引号括起来)来命名。 对象语法属性值与数据变量绑定。 例1将内联样式写在了标签内。 例2封装了一个样式对象，使标签更简洁。 例3一个应用。 代码片段 123456789101112131415161718192021222324252627282930313233343536373839e.g.1&lt;div v-bind:style&#x3D;&quot;&#123; color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;data: &#123; activeColor: &#39;red&#39;, fontSize: 30&#125;e.g.2&lt;div v-bind:style&#x3D;&quot;styleObject&quot;&gt;&lt;&#x2F;div&gt;data: &#123; styleObject: &#123; color: &#39;red&#39;, fontSize: &#39;13px&#39; &#125;&#125;e.g.3&lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;div :style&#x3D;&quot;styleObj&quot; @click&#x3D;&quot;handleDivClick&quot;&gt; Hello world &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script&gt; var vm &#x3D; new Vue(&#123; el: &quot;#app&quot;, data: &#123; styleObj: &#123; color: &quot;black&quot; &#125; &#125;, methods: &#123; handleDivClick: function () &#123; this.styleObj.color &#x3D; this.styleObj.color &#x3D;&#x3D;&#x3D; &quot;black&quot; ? &quot;red&quot; : &quot;black&quot;; &#125; &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 数组语法其实数组里面放置的还是对象 代码片段 12e.g.4&lt;div v-bind:style&#x3D;&quot;[styleObj, &#123;fontSize: &#39;20px&#39;&#125;]&quot;&gt;&lt;&#x2F;div&gt; template占位在Vue中可用templat标签作为父元素将某些标签包裹起来，template标签只是个占位元素，页面在渲染时并不会渲染出template标签。这样就能达到将某些标签组合起来但又不想新增标签的效果。常见于条件渲染和循环渲染。 在下面的v-if，因为v-if是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个&lt;template&gt;元素当做不可见的包裹元素，并在上面使用v-if。最终的渲染结果将不包含&lt;template&gt;元素。 代码片段 123456e.g.1&lt;template v-if&#x3D;&quot;ok&quot;&gt; &lt;h1&gt;Title&lt;&#x2F;h1&gt; &lt;p&gt;Paragraph 1&lt;&#x2F;p&gt; &lt;p&gt;Paragraph 2&lt;&#x2F;p&gt;&lt;&#x2F;template&gt; 用key管理可复用的元素Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。常见于条件渲染和循环渲染，避免某些麻烦。 例3中，切换loginType将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，&lt;input&gt;不会被替换掉，仅仅是替换了placeholder。只需添加一个具有唯一值的key即可，表示这两个元素是独立的，不要复用。而lable标签会复用，因为没有key属性。 代码片段 1234567e.g.3&lt;template v-if&#x3D;&quot;loginType &#x3D;&#x3D;&#x3D; &#39;username&#39;&quot;&gt;&lt;label&gt;用户名：&lt;&#x2F;label&gt;&lt;input placeholder&#x3D;&quot;Enter your username&quot;&gt;&lt;&#x2F;template&gt;&lt;template v-else&gt;&lt;label&gt;邮箱：&lt;&#x2F;label&gt;&lt;input placeholder&#x3D;&quot;Enter your email address&quot;&gt;&lt;&#x2F;template&gt; 条件渲染通过在标签上内置v-if指令达到简单的判断显示效果。 v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。 代码片段 12345e.g.1&lt;div v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;A&#39;&quot;&gt;A&lt;&#x2F;div&gt;&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;B&#39;&quot;&gt;B&lt;&#x2F;div&gt;&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;C&#39;&quot;&gt;C&lt;&#x2F;div&gt;&lt;div v-else&gt;Not A&#x2F;B&#x2F;C&lt;&#x2F;div&gt; v-if与v-showv-if是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。也是惰性的，如果在初始渲染时条件为假，则什么也不做，就是不参与渲染，直到条件第一次变为真时，才会开始渲染条件块。 v-show不支持&lt;template&gt;元素和v-else。 相比之下，v-show就简单得多，不管初始条件是什么，元素总是会被渲染，并且只是简单地基于CSS进行切换。 与v-if的最大不同就是v-if不渲染元素，v-show会始终渲染元素并保留在DOM中，只是display=none。 一般来说，v-if有更高的切换开销，而v-show有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用v-show较好；如果在运行时条件很少改变，则使用v-if较好。 循环渲染循环数组v-for指令基于一个数组来渲染一个列表。v-for指令需要使用item in items形式的特殊语法，其中items是源数据数组，而item则是被迭代的数组元素的别名。在v-for 块中，可以访问所有父作用域的property。v-for还支持一个可选的第二个参数，即当前项的索引。 代码片段 1234567891011121314151617e.g.1&lt;ul id&#x3D;&quot;root&quot;&gt; &lt;li v-for&#x3D;&quot;(item, index) in list&quot;&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;var vm &#x3D; new Vue(&#123; el: &#39;#root&#39;, data: &#123; parentMessage: &#39;Parent&#39;, list: [ &#123; message: &#39;Foo&#39; &#125;, &#123; message: &#39;Bar&#39; &#125; ] &#125;&#125;) 循环对象用v-for来遍历一个对象的property。value键值必选，name键名和index索引可选。 代码片段 123456789101112131415e.g.1&lt;div v-for&#x3D;&quot;(value, name, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;&#x2F;div&gt;new Vue(&#123; el: &#39;#v-for-object&#39;, data: &#123; object: &#123; title: &#39;How to do lists in Vue&#39;, author: &#39;Jane Doe&#39;, publishedAt: &#39;2016-04-10&#39; &#125; &#125;&#125;) 循环组件可以像普通元素一样在组件上使用v-for，这时，必须要有key。然而，任何数据都不会被自动传递到组件里，如例1，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用prop，如例2，见父子组件传值。 例1中，组件里并没有item数据。还是依靠props进行传值，如例2. 代码片段 12345678910e.g.1&lt;my-component v-for&#x3D;&quot;item in items&quot; :key&#x3D;&quot;item.id&quot;&gt;&lt;&#x2F;my-component&gt;e.g.2&lt;my-component v-for&#x3D;&quot;(item, index) in items&quot; v-bind:item&#x3D;&quot;item&quot; v-bind:index&#x3D;&quot;index&quot; v-bind:key&#x3D;&quot;item.id&quot;&gt;&lt;&#x2F;my-component&gt; 更新数组Vue不支持根据索引下标修改数组，而提供了封装的方法：push()、pop()、shift()、unshift()、splice()、sort()、reverse()。 另外，改变数据对数组的引用，就是重新赋值，同样能修改页面中显示的数据。如vm.list=[新的数组]。 还有个方法就是用全局API，set方法。如Vue.set(object,2,&#39;hehe&#39;)。见set方法。 更新对象Vue中不支持根据键名来修改值，可以改变数据变量对对象的引用，就是将变量重新赋值，就能修改数据。 另外，可以用全局API，set方法。如Vue.set(object,&#39;name&#39;,&#39;hehe&#39;)。见set方法。 循环与函数配合有时要对循环的数据进行一些处理后再输出渲染，此时可配合函数使用。 常见的需求是循环嵌套循环，如例1。循环中判断该项是否符合条件，如例2。 重点在于循环与条件判断如何配合。首先会想到v-for与v-if配合，如例3，但是Vue不建议这样做。首先，会极大的消耗性能，要遍历整个列表，而展示的数据并不多，这就有许多不必要的遍历。可以先利用函数对数据进行处理，遍历的时候就遍历这个函数返回的数据，这个数据就已经是想要的结果，没有遍历多余的元素。 如例4的做法比例3更好，直接用computed属性写个函数将活跃用户选出来放到数组中，遍历的时候就遍历这个数组即可，这样所有的循环项就都是活跃用户了，没有遍历多余的数据。例2也是用computed属性写个函数计算数组的结果，并没用v-if。 将computed换成methods也可以，这样函数就从计算属性变成了方法，循环时要给方法加上括号，如例4的v-for=&quot;user in activeUsers()&quot;。 代码片段 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061e.g.1&lt;ul v-for&#x3D;&quot;set in sets&quot;&gt; &lt;li v-for&#x3D;&quot;n in even(set)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;data: &#123; sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]&#125;,methods: &#123; even: function (numbers) &#123; return numbers.filter(function (number) &#123; return number % 2 &#x3D;&#x3D;&#x3D; 0 &#125;) &#125;&#125;e.g.2&lt;li v-for&#x3D;&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;&#x2F;li&gt;data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 &#x3D;&#x3D;&#x3D; 0 &#125;) &#125;&#125;e.g.3&lt;ul&gt; &lt;li v-for&#x3D;&quot;user in users&quot; v-if&#x3D;&quot;user.isActive&quot; :key&#x3D;&quot;user.id&quot; &gt; &#123;&#123; user.name &#125;&#125; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&#x2F;&#x2F; v-for与v-if配合，其中的计算过程如下this.users.map(function (user) &#123; if (user.isActive) &#123; return user.name &#125;&#125;)e.g.4&lt;ul&gt; &lt;li v-for&#x3D;&quot;user in activeUsers&quot; :key&#x3D;&quot;user.id&quot; &gt; &#123;&#123; user.name &#125;&#125; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;computed: &#123; activeUsers: function () &#123; return this.users.filter(function (user) &#123; return user.isActive &#125;) &#125;&#125; 事件基本Vue中用v-on指令监听DOM事件，并在触发时运行一些JavaScript代码。常用的是绑定函数，如例2，不直接绑定代码块如例1。 代码片段 12345678910e.g.1&lt;button v-on:click&#x3D;&quot;console.log(233)&quot;&gt;按钮&lt;&#x2F;button&gt;e.g.2&lt;button v-on:click&#x3D;&quot;handleClick&quot;&gt;按钮&lt;&#x2F;button&gt;methods:&#123; handleClick:function()&#123; console.log(233); &#125;&#125; 事件参数e要使用事件参数，绑定函数的操作如例1，函数不加括号。如果想加括号，绑定时必须加上$event才能获取事件参数，如例2，其他的参数可选。如果绑定时加了括号但不写$event，就打印undefined。 代码片段 123456789101112131415e.g.1&lt;button v-on:click&#x3D;&quot;handleClick&quot;&gt;按钮&lt;&#x2F;button&gt;methods:&#123; handleClick:function(e)&#123; console.log(e); &#125;&#125;e.g.2&lt;button v-on:click&#x3D;&quot;handleClick($event,arg1,arg2)&quot;&gt;按钮&lt;&#x2F;button&gt;methods:&#123; handleClick:function(e,arg1,arg2)&#123; console.log(e,arg1,arg2); &#125;&#125; 事件修饰符如阻止默认行为和阻止冒泡，虽然可在语句中写上event.preventDefault()、event.stopPropagation()，但Vue的风格是尽可能不去操作DOM，只关心数据处理，以数据为中心。所以Vue提供一些事件修饰符解决一些操作DOM的细节。 修饰符可以连用。&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt; 修饰符可以单用。&lt;a v-on:click.prevent&gt;&lt;/a&gt; 不同的顺序有不同的效果。使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用v-on:click.prevent.self会阻止所有的点击，而v-on:click.self.prevent只会阻止对元素自身的点击。 .stop：阻止冒泡.prevent：阻止默认行为.capture：设为捕获阶段执行.self：event.target===event.currentTarget，即绑定事件和触发事件的元素都是自己时才执行函数.once：只执行一次，自定义组件也可用.passive：告诉浏览器不会阻止默认行为。常用于移动端滚动事件。 按键修饰符监听键盘事件时，有时需要判断某一个按键是否被按下，才决定执行函数。大致有以下常用的，具体增加其他的按键做法见Vue官网-按键修饰符。 .enter.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right 例1中，绑定keyup事件，如果没用enter修饰符，那么每次输入抬起按键就会输出一堆文本，加上enter修饰符后，输入完毕，只有按下enter键才会执行函数。 代码片段 1234567e.g.1&lt;input @keyup.enter&#x3D;&quot;keyUp&quot;&#x2F;&gt;methods: &#123; keyUp: function (e) &#123; console.log(e.target.value); &#125;&#125; 系统修饰键可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。.ctrl.alt.shift.meta 注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。 系统修饰键与常规按键不同，在和keyup事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住ctrl的情况下释放其它按键，才能触发keyup.ctrl。而单单释放ctrl也不会触发事件。 .exact修饰符.exact：控制由精确的系统修饰符组合触发的事件。如例1. 代码片段 1234567e.g.1&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button v-on:click.ctrl&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button v-on:click.ctrl.exact&#x3D;&quot;onCtrlClick&quot;&gt;A&lt;&#x2F;button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button v-on:click.exact&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt; 鼠标按钮修饰符这些修饰符会限制处理函数仅响应特定的鼠标按钮。 .left.right.middle 表单输入绑定基本可以用v-model指令在表单&lt;input&gt;、&lt;textarea&gt;及&lt;select&gt;元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。 v-model会忽略所有表单元素的value、checked、selected、attribute的初始值而总是将Vue实例的data数据作为数据来源。所以要通过JS在组件的data选项中声明初始值。 其实v-model在内部为不同的输入元素使用不同的property并抛出不同的事件。 text和textarea元素使用value、property和input事件； checkbox和radio使用checked、property和change事件； select字段将value作为prop并将change作为事件。 v-model对于input和textarea绑定value值。 在文本区域插值(&lt;textarea&gt;&lt;/textarea&gt;)并不会生效，应用v-model来代替。 对于checkbox绑定true/false，如果有value值，那么就绑定value值。 对于radio绑定value值，不设value就为空。 对于select绑定option的value值，不设value就绑定option的innerText 代码片段 12345678910111213141516171819202122232425262728293031e.g.1&lt;input v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;edit me&quot;&gt;e.g.2&lt;textarea v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;add multiple lines&quot;&gt;&lt;&#x2F;textarea&gt;e.g.3&lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;checked&quot;&gt;e.g.4&lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;jack&quot; value&#x3D;&quot;Jack&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;&lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;john&quot; value&#x3D;&quot;John&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;&lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;mike&quot; value&#x3D;&quot;Mike&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;data:&#123; checkedNames:[]&#125;e.g.5&lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;one&quot; value&#x3D;&quot;One&quot; v-model&#x3D;&quot;picked&quot;&gt;&lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;two&quot; value&#x3D;&quot;Two&quot; v-model&#x3D;&quot;picked&quot;&gt;data:&#123; picked:&#39;&#39;&#125;e.g.6&lt;select v-model&#x3D;&quot;selected&quot;&gt; &lt;option disabled value&#x3D;&quot;&quot;&gt;请选择&lt;&#x2F;option&gt; &lt;option&gt;A&lt;&#x2F;option&gt; &lt;option&gt;B&lt;&#x2F;option&gt; &lt;option&gt;C&lt;&#x2F;option&gt;&lt;&#x2F;select&gt; 修饰符.lazy在默认情况下，v-model在每次input事件触发后将输入框的值与数据进行同步(除了上述输入法组合文字时)。你可以添加lazy修饰符，从而转为在change事件之后进行同步。就是输入完成，失去焦点后再同步数据。 &lt;input v-model.lazy=&quot;msg&quot;&gt; .number自动将用户输入的数字转为数字类型，其他的字符不做更改。这通常很有用，因为即使input标签在type=&quot;number&quot;时，HTML输入元素的值也总会返回字符串。如果这个值无法被parseFloat()解析，则会返回原始的值。 &lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt; .trim自动过滤用户输入的首尾空白字符 &lt;input v-model.trim=&quot;msg&quot;&gt; transitionvue中的transtion是一个动画过渡封装组件，常见的情景使用transition标签包裹的DOM含有动画效果。transition组件的动画效果过渡设置基于css的transition属性设置。 vue提供的wrapper包装组件——transition，在包裹的元素中，有涉及到v-if，v-show, 动态组件,组件根节点,，都会给它们添加进入/离开的过渡效果。 Vue中，在进入/离开的过渡中，会有6个class切换。通过指定不同的class来添加样式达到过渡的CSS效果。这6个class，分别是如下。 1、v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。2、v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。3、v-enter-to：2.1.8 版及以上定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。4、v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。5、v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。6、v-leave-to：2.1.8 版及以上定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时v-leave被删除)，在过渡/动画完成之后移除。 注意：默认类名是以上6个（transition没有设置name属性的时候，则v-是这些类名的默认前缀），如果在transition标签中指定了name=” xxx”,那么6个类名将会变成xxx开头的，例如：&lt;transition name=&quot;my-transition&quot;&gt;，那么v-enter会替换为my-transition-enter。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lifenobody.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lifenobody.github.io/tags/Vue/"},{"name":"基础","slug":"基础","permalink":"https://lifenobody.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"first","slug":"first","date":"2020-06-22T09:30:54.000Z","updated":"2020-06-28T06:35:58.760Z","comments":true,"path":"2020/06/22/first/","link":"","permalink":"https://lifenobody.github.io/2020/06/22/first/","excerpt":"","text":"先搞个博客玩玩。","categories":[],"tags":[]}],"categories":[{"name":"js","slug":"js","permalink":"https://lifenobody.github.io/categories/js/"},{"name":"Vue","slug":"Vue","permalink":"https://lifenobody.github.io/categories/Vue/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://lifenobody.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"js","slug":"js","permalink":"https://lifenobody.github.io/tags/js/"},{"name":"Vue","slug":"Vue","permalink":"https://lifenobody.github.io/tags/Vue/"}]}